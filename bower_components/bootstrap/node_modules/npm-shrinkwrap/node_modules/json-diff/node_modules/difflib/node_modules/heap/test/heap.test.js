// Generated by CoffeeScript 1.9.0
var Heap, random;

Heap = require('..');

random = Math.random;

describe('Heap#push, Heap#pop', function() {
  it('should sort an array using push and pop', function() {
    var heap, i, sorted, _i;
    heap = new Heap;
    for (i = _i = 1; _i <= 10; i = ++_i) {
      heap.push(random());
    }
    sorted = ((function() {
      var _results;
      _results = [];
      while (!heap.empty()) {
        _results.push(heap.pop());
      }
      return _results;
    })());
    return sorted.slice().sort().should.eql(sorted);
  });
  return it('should work with custom comparison function', function() {
    var cmp, heap, i, sorted, _i;
    cmp = function(a, b) {
      if (a > b) {
        return -1;
      }
      if (a < b) {
        return 1;
      }
      return 0;
    };
    heap = new Heap(cmp);
    for (i = _i = 1; _i <= 10; i = ++_i) {
      heap.push(random());
    }
    sorted = ((function() {
      var _results;
      _results = [];
      while (!heap.empty()) {
        _results.push(heap.pop());
      }
      return _results;
    })());
    return sorted.slice().sort().reverse().should.eql(sorted);
  });
});

describe('Heap#replace', function() {
  return it('should behave like pop() followed by push()', function() {
    var heap, v, _i;
    heap = new Heap;
    for (v = _i = 1; _i <= 5; v = ++_i) {
      heap.push(v);
    }
    heap.replace(3).should.eql(1);
    return heap.toArray().sort().should.eql([2, 3, 3, 4, 5]);
  });
});

describe('Heap#pushpop', function() {
  return it('should behave like push() followed by pop()', function() {
    var heap, v, _i;
    heap = new Heap;
    for (v = _i = 1; _i <= 5; v = ++_i) {
      heap.push(v);
    }
    heap.pushpop(6).should.eql(1);
    return heap.toArray().sort().should.eql([2, 3, 4, 5, 6]);
  });
});

describe('Heap#contains', function() {
  return it('should return whether it contains the value', function() {
    var heap, v, _i, _j;
    heap = new Heap;
    for (v = _i = 1; _i <= 5; v = ++_i) {
      heap.push(v);
    }
    for (v = _j = 1; _j <= 5; v = ++_j) {
      heap.contains(v).should.be["true"];
    }
    heap.contains(0).should.be["false"];
    return heap.contains(6).should.be["false"];
  });
});

describe('Heap#peek', function() {
  return it('should return the top value', function() {
    var heap;
    heap = new Heap;
    heap.push(1);
    heap.peek().should.eql(1);
    heap.push(2);
    heap.peek().should.eql(1);
    heap.pop();
    return heap.peek().should.eql(2);
  });
});

describe('Heap#clone', function() {
  return it('should return a cloned heap', function() {
    var a, b, v, _i;
    a = new Heap;
    for (v = _i = 1; _i <= 5; v = ++_i) {
      a.push(v);
    }
    b = a.clone();
    return a.toArray().should.eql(b.toArray());
  });
});

describe('Heap.nsmallest', function() {
  it('should return exactly n elements when size() >= n', function() {
    var array;
    Heap.nsmallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3).should.eql([1, 2, 3]);
    array = [1, 3, 2, 1, 3, 4, 4, 2, 3, 4, 5, 1, 2, 3, 4, 5, 2, 1, 3, 4, 5, 6, 7, 2];
    return Heap.nsmallest(array, 2).should.eql([1, 1]);
  });
  return it('should return size() elements when size() <= n', function() {
    return Heap.nsmallest([3, 2, 1], 10).should.eql([1, 2, 3]);
  });
});

describe('Heap.nlargest', function() {
  it('should return exactly n elements when size() >= n', function() {
    return Heap.nlargest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3).should.eql([10, 9, 8]);
  });
  return it('should return size() elements when size() <= n', function() {
    return Heap.nlargest([3, 2, 1], 10).should.eql([3, 2, 1]);
  });
});

describe('Heap#updateItem', function() {
  it('should return correct order', function() {
    var a, b, c, h;
    a = {
      x: 1
    };
    b = {
      x: 2
    };
    c = {
      x: 3
    };
    h = new Heap(function(m, n) {
      return m.x - n.x;
    });
    h.push(a);
    h.push(b);
    h.push(c);
    c.x = 0;
    h.updateItem(c);
    return h.pop().should.eql(c);
  });
  return it('should return correct order when used statically', function() {
    var a, b, c, cmp, h;
    a = {
      x: 1
    };
    b = {
      x: 2
    };
    c = {
      x: 3
    };
    h = [];
    cmp = function(m, n) {
      return m.x - n.x;
    };
    Heap.push(h, a, cmp);
    Heap.push(h, b, cmp);
    Heap.push(h, c, cmp);
    c.x = 0;
    Heap.updateItem(h, c, cmp);
    return Heap.pop(h, cmp).should.eql(c);
  });
});

//# sourceMappingURL=heap.test.js.map
